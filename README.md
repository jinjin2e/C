# 문법 및 컴퓨터 등



***  



# 구조체 
> 구조체(struct)란 사용자가 C언어의 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 타입입니다.  
> 배열이 같은 타입의 변수 집합이라고 한다면, 구조체는 다양한 타입의 변수 집합을 하나의 타입으로 나타낸 것입니다.     
> 이때 구조체를 구성하는 변수를 구조체의 멤버(member) 또는 멤버 변수(member variable)라고 합니다.  
>
> struct book // 구조체의 선언, 사용할 멤버들 선언을 해준다.   
> {  
>    char title[30];  
>    char author[30];  
>    int price;  
> };    
> int main(void)  
> {  
>    struct book my_book = {"HTML과 CSS", "홍길동", 28000};   // struct book 과 같은 구조를 사용하는 my book 이라는 변수를 만듦 > my book의 값을 설정   
>    struct book java_book = {.title = "Java language", .price = 30000}; // struct book 의 구조로 java_book 이라는 변수를 만듦, 형식만 book 의 형식을 가져와 새로 만들어 my_book 변수와는 별개의 변수이기때문에 멤버의 값을 공유하지 않음(별개의 변수임)   
>   
>    printf("첫 번째 책의 제목은 %s이고, 저자는 %s이며, 가격은 %d원입니다.\n",  
>        my_book.title, my_book.author, my_book.price);    
>          
>    printf("두 번째 책의 제목은 %s이고, 저자는 %s이며, 가격은 %d원입니다.\n",  
>        java_book.title, java_book.author, java_book.price); // 초기화를 하면서 java_book 구조체 변수의 멤버 중 .author 은 정의하지 않았기 때문에 0이 들어가있음.  
>
>    return 0;  
> }
> 결과  
> 첫 번째 책의 제목은 HTML과 CSS이고, 저자는 홍길동이며, 가격은 28000원입니다.  
> 두 번째 책의 제목은 Java language이고, 저자는 이며, 가격은 30000원입니다.



***



# const(상수)
> const는 변수값을 상수화시키는 문법입니다.  
> 
> 변수는 계속해서 값을 바꿀 수 있지만 상수는 한번 값을 정하면 변경할 수 없습니다.  
> 
> 초깃값이 변하지 않아야 할 때 사용합니다 ex) PI = 3.14  
> 
> 만들어놓은 const 상수에 다른 값을 집어넣으려 한다면 컴파일에서 오류가 발생합니다.  
> ex) const int a = 2;  
>     a = 10; (err)  
> 
> 선언할 때의 순서는 상관없습니다(포인터일 때만 제외하면).  ex) const int a; == int const a;



***



# 포인터
> 포인터란 메모리의 주소값을 저장하는 변수 = 포인터변수

### 포인터를 사용하는 이유
> 1. 메모리 주소를 참조하여 복잡한 자료구조를 효율적으로 처리할 수 있음
> 2. 배열로 생성할 수 없는 데이터를 생성할 수 있음
> 3. 메모리 공간의 효율적인 사용이 가능함  

### 포인터의 선언 (포인터 변수)
> 1. 변수타입 *포인터변수명 = &참조할 변수이름;  
> 2. 변수타입 *포인터변수명 = 주소값;(주소값이므로 포인터를 포인터 할 수 있음)  


<pre>
<code>
uint32_t A = 10; // 일반 변수 선언    
uint32_t *ptr_A = &A //A를 포인터하는 변수 선언  
uint32_t *pptr_A = &ptr_A //A를 포인터하는 ptr_A 를 포인터하는 변수 선언  
</code>
</pre>



### 포인터 변수에 사용되는 연산자
#### 1. &(주소 연산자)  
> 앰퍼샌드(ampersand) 라고 읽습니다 = 번지 연산자  
> 변수의 이름 앞에 사용해서 변수의 주소값을 반환합니다. (포인터 변수를 선언 할 때 값 부분, 또는 인자값을 포인터로 받는 함수에서 사용했음)    
#### 2. *(참조 연산자)
> 포인터의 이름이나 주소 앞에 사용함(포인터 변수를 선언 할 떄 변수명 앞쪽에 사용, 또는 메모리 주소에 접근해 값을 이용할 때 사용했음)    
> 포인터가 가리키는 주소에 들어있는 값을 반환함



***
# 메모리 이해  
 ## 메모리의 구조 
 ### 1. 코드 영역 
 > code
 ### 2. 데이터 영역
 > data
 ### 3. 힙 영역 
 > heap
 ### 4. 스택 영역
 > stack
***
# memset()
> 메모리를 할당받은 변수의 공간에는 쓰레기값들이 남아있습니다. 이러한 쓰레기 값들을 0으로 초기화시키기 위해 사용할 수 있는 방법 중 하나가 memset 함수를 사용하는 것입니다.
### 사용 목적
> 배열 초기화: 배열을 특정한 값으로 초기화하는 데 사용됩니다. 예를 들어, 정수 배열이나 문자열 배열을 0으로 초기화하거나 다른 특정한 값으로 초기화할 때 memset() 함수를 활용할 수 있습니다.
>
> 동적 할당된 메모리 초기화: malloc() 또는 calloc() 함수 등을 사용하여 동적으로 메모리를 할당한 후, 해당 메모리 블록을 특정 값으로 초기화하는 데 사용됩니다.
>
> 비트맵 초기화: 특정 비트맵 데이터 구조를 초기화할 때 memset() 함수를 사용할 수 있습니다. 이는 0 또는 1과 같은 비트 값을 설정하는 데 유용합니다.
>
> 구조체 초기화: 구조체의 멤버 변수를 초기화할 때 memset() 함수를 사용할 수 있습니다. 이때 주의할 점은 구조체의 멤버 변수가 모두 0 또는 특정한 값으로 초기화되어야 하는 경우에만 적용할 수 있습니다. 만약 구조체의 멤버 변수가 포인터 등의 복잡한 자료형을 가질 경우 사용에 주의해야 합니다.  
>```
> #include <string.h>  //C언어
> #include <cstring.h> //C++
> void* memset(void* ptr, int value, size_t num);
>```
> 인자값 정리  
> ```
> ptr : 메모리의 크기를 변경할 포인터(변수)  
> value : 초기화 값 (변경될 값)  
> size : 초기화할 메모리의 크기(개수)  
> ```
***
# 배열과 포인터  
***
# I2C
>
> I2C의 정의
>
> Inter-Integrated Circuit(I2C) 프로토콜은 IC 사이에 통신 링크를 제공하는 양방향 2 와이어 직렬 버스이다.
> ## 특징 
> - I2C 통신은 2개의 선을 이용하는 통신 방식
>
> - 하나의 마스터와 여러개의 슬레이브 기기가 물려 통신이 가능
>
> - 클럭 신호를 사용하는 동기식 통신 방식이라 시간에 자유로움
>
> - 슬레이브 선택을 위해 항상 주소 데이터가 붙기에 긴 데이터를 전송 하기엔 부적합

## 통신 방식 
![image](https://github.com/jinjin2e/C/assets/93366905/b24fe750-0504-4a8a-8880-9c6f5d25f8ee)

기본적으로 마스터와 슬레이브 사이 2선으로 구성된다.

첫번째 가닥은 SDA 선이다. 이는 데이터를 주고 받기 위한 선이다.

두번째 가닥은 SCL 선이다. 이는 타이밍을 동기화 하기 위한 클럭 선이다.

하나의 마스터와, 다른 하나의 슬레이브로 구성이 된다. 그리고 슬레이브는 127개까지 구성이 가능하다.

즉, 메인 ECU가 있으면, 그 외 여러가지 디바이스들이 묶여 통신이 가능 하다는 이야기 이다.

![image](https://github.com/jinjin2e/C/assets/93366905/8526828a-5ad4-4c17-a3e5-4a09d4b20893)

## 신호의 종류

- ACK - 수신측에서 메세지를 에러없이 정상적으로 수신했거나, 송신해도 된다는 것을 송신측에 알리기 위한 제어용 신호
- NAK - 정상적으로 수신하지 못헀거나 수신할 수 없다는 것을 송신측에 알리기 위한 제어용 신호
  
보통 바이트의 마지막 비트를 ACK 신호로 사용 (1이면 ACK 0이면 NAK)

## HAL_I2C_Master_seq_Transmit_IT()

Seq_transmit_IT 함수, 연속적으로 데이터를 전송하는 함수이다. I2C INT 를사용하려면 MX또는 IOC 파일에서 I2C global init 을 체크 해줘야 한다.
아래 코드는 성공적으로 전송이 완료되었는지 확인하는 코드이다. 성공적으로 전송이 완료되었다면 HAL_OK를 반환(seq_transmit_it 함수가 status 변수에) 아니라면 HAL_BUSY 또는 HAL_ERR를 반환시키므로 전송의 성공 여부를 판별할 수 있다. 

HAL_StatusTypeDef status = HAL_OK;

status = HAL_I2C_Master_Seq_Transmit_IT(platform->hi2c, STWBC86_I2C_ADDR << 1, wbuf, wlen, I2C_FIRST_AND_LAST_FRAME); // STWBC86_I2C_ADDR = 0x61
if(status != HAL_OK)
    return status;

## 


***
# SPI
***
## 메모리 
![image](https://github.com/jinjin2e/C/assets/93366905/f005b3a1-a876-49c7-84d5-806f9f587926)
flash에 저장된 값과 주소 읽기

