# 문법 및 컴퓨터 등



***  



# 구조체 
> 구조체(struct)란 사용자가 C언어의 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 타입입니다.  
> 배열이 같은 타입의 변수 집합이라고 한다면, 구조체는 다양한 타입의 변수 집합을 하나의 타입으로 나타낸 것입니다.     
> 이때 구조체를 구성하는 변수를 구조체의 멤버(member) 또는 멤버 변수(member variable)라고 합니다.  
>
> struct book // 구조체의 선언, 사용할 멤버들 선언을 해준다.   
> {  
>    char title[30];  
>    char author[30];  
>    int price;  
> };    
> int main(void)  
> {  
>    struct book my_book = {"HTML과 CSS", "홍길동", 28000};   // struct book 과 같은 구조를 사용하는 my book 이라는 변수를 만듦 > my book의 값을 설정   
>    struct book java_book = {.title = "Java language", .price = 30000}; // struct book 의 구조로 java_book 이라는 변수를 만듦, 형식만 book 의 형식을 가져와 새로 만들어 my_book 변수와는 별개의 변수이기때문에 멤버의 값을 공유하지 않음(별개의 변수임)   
>   
>    printf("첫 번째 책의 제목은 %s이고, 저자는 %s이며, 가격은 %d원입니다.\n",  
>        my_book.title, my_book.author, my_book.price);    
>          
>    printf("두 번째 책의 제목은 %s이고, 저자는 %s이며, 가격은 %d원입니다.\n",  
>        java_book.title, java_book.author, java_book.price); // 초기화를 하면서 java_book 구조체 변수의 멤버 중 .author 은 정의하지 않았기 때문에 0이 들어가있음.  
>
>    return 0;  
> }
> 결과  
> 첫 번째 책의 제목은 HTML과 CSS이고, 저자는 홍길동이며, 가격은 28000원입니다.  
> 두 번째 책의 제목은 Java language이고, 저자는 이며, 가격은 30000원입니다.



***



# const(상수)
> const는 변수값을 상수화시키는 문법입니다.  
> 
> 변수는 계속해서 값을 바꿀 수 있지만 상수는 한번 값을 정하면 변경할 수 없습니다.  
> 
> 초깃값이 변하지 않아야 할 때 사용합니다 ex) PI = 3.14  
> 
> 만들어놓은 const 상수에 다른 값을 집어넣으려 한다면 컴파일에서 오류가 발생합니다.  
> ex) const int a = 2;  
>     a = 10; (err)  
> 
> 선언할 때의 순서는 상관없습니다(포인터일 때만 제외하면).  ex) const int a; == int const a;



***



# 포인터
> 포인터란 메모리의 주소값을 저장하는 변수 = 포인터변수

### 포인터를 사용하는 이유
> 1. 메모리 주소를 참조하여 복잡한 자료구조를 효율적으로 처리할 수 있음
> 2. 배열로 생성할 수 없는 데이터를 생성할 수 있음
> 3. 메모리 공간의 효율적인 사용이 가능함  

### 포인터의 선언 (포인터 변수)
> 1. 변수타입 *포인터변수명 = &참조할 변수이름;  
> 2. 변수타입 *포인터변수명 = 주소값;(주소값이므로 포인터를 포인터 할 수 있음)  


<pre>
<code>
uint32_t A = 10; // 일반 변수 선언    
uint32_t *ptr_A = &A //A를 포인터하는 변수 선언  
uint32_t *pptr_A = &ptr_A //A를 포인터하는 ptr_A 를 포인터하는 변수 선언  
</code>
</pre>



### 포인터 변수에 사용되는 연산자
#### 1. &(주소 연산자)  
> 앰퍼샌드(ampersand) 라고 읽습니다 = 번지 연산자  
> 변수의 이름 앞에 사용해서 변수의 주소값을 반환합니다. (포인터 변수를 선언 할 때 값 부분, 또는 인자값을 포인터로 받는 함수에서 사용했음)    
#### 2. *(참조 연산자)
> 포인터의 이름이나 주소 앞에 사용함(포인터 변수를 선언 할 떄 변수명 앞쪽에 사용, 또는 메모리 주소에 접근해 값을 이용할 때 사용했음)    
> 포인터가 가리키는 주소에 들어있는 값을 반환함



***
# 메모리 이해  
 ## 메모리의 구조 
 ### 1. 코드 영역 
 > code
 ### 2. 데이터 영역
 > data
 ### 3. 힙 영역 
 > heap
 ### 4. 스택 영역
 > stack
***
# memset()
> 메모리를 할당받은 변수의 공간에는 쓰레기값들이 남아있습니다. 이러한 쓰레기 값들을 없애서 초기화시키기 위해 사용할 수 있는 방법 중 하나가 memset 함수를 사용하는 것입니다.
### 사용 목적
> 배열 초기화: 배열을 특정한 값으로 초기화하는 데 사용됩니다. 예를 들어, 정수 배열이나 문자열 배열을 0으로 초기화하거나 다른 특정한 값으로 초기화할 때 memset() 함수를 활용할 수 있습니다.

> 동적 할당된 메모리 초기화: malloc() 또는 calloc() 함수 등을 사용하여 동적으로 메모리를 할당한 후, 해당 메모리 블록을 특정 값으로 초기화하는 데 사용됩니다.
>
> 비트맵 초기화: 특정 비트맵 데이터 구조를 초기화할 때 memset() 함수를 사용할 수 있습니다. 이는 0 또는 1과 같은 비트 값을 설정하는 데 유용합니다.
>
> 구조체 초기화: 구조체의 멤버 변수를 초기화할 때 memset() 함수를 사용할 수 있습니다. 이때 주의할 점은 구조체의 멤버 변수가 모두 0 또는 특정한 값으로 초기화되어야 하는 경우에만 적용할 수 있습니다. 만약 구조체의 멤버 변수가 포인터 등의 복잡한 자료형을 가질 경우 사용에 주의해야 합니다.  
>```
> #include <string.h>  //C언어
> #include <cstring.h> //C++
> void* memset(void* ptr, int value, size_t num);
>```
> 인자값 정리  
> ```
> ptr : 메모리의 크기를 변경할 포인터(변수)  
> value : 초기화 값 (변경될 값)  
> size : 초기화할 메모리의 크기(개수)  
> ```
***
# 배열과 포인터  
***
# I2C
***
# SPI

